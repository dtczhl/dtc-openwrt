Index: linux-4.9.82/net/Makefile
===================================================================
--- linux-4.9.82.orig/net/Makefile
+++ linux-4.9.82/net/Makefile
@@ -10,6 +10,9 @@ obj-$(CONFIG_NET)		:= socket.o core/
 tmp-$(CONFIG_COMPAT) 		:= compat.o
 obj-$(CONFIG_NET)		+= $(tmp-y)
 
+# added by dtc ------
+obj-y   += ../../../../../common_folder/dtc_debugfs/
+
 # LLC has to be linked before the files in net/802/
 obj-$(CONFIG_LLC)		+= llc/
 obj-$(CONFIG_NET)		+= ethernet/ 802/ sched/ netlink/
Index: linux-4.9.82/net/socket.c
===================================================================
--- linux-4.9.82.orig/net/socket.c
+++ linux-4.9.82/net/socket.c
@@ -108,6 +108,9 @@
 #include <net/busy_poll.h>
 #include <linux/errqueue.h>
 
+// added by dtc ------
+#include "../../../../../common_folder/dtc_debugfs/dtc_debugfs.h"
+
 #ifdef CONFIG_NET_RX_BUSY_POLL
 unsigned int sysctl_net_busy_read __read_mostly;
 unsigned int sysctl_net_busy_poll __read_mostly;
@@ -2537,6 +2540,13 @@ static int __init sock_init(void)
 
 	ptp_classifier_init();
 
+    // added by dtc ------
+    if (dtc_init_debugfs("dtcSock", 2) == 0) {
+        printk(KERN_ALERT "dtc: in sock_init, init_debugfs succeeds\n");
+    } else {
+        printk(KERN_ALERT "dtc: in sock_init, init_debugfs fails\n");
+    }
+
 out:
 	return err;
 
Index: linux-4.9.82/net/ipv4/ip_output.c
===================================================================
--- linux-4.9.82.orig/net/ipv4/ip_output.c
+++ linux-4.9.82/net/ipv4/ip_output.c
@@ -80,6 +80,9 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
+// added by dtc ------
+#include "../../../../../../common_folder/dtc_debugfs/dtc_debugfs.h"
+
 static int
 ip_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,
 	    unsigned int mtu,
@@ -118,6 +121,14 @@ int ip_local_out(struct net *net, struct
 {
 	int err;
 
+    // added by dtc ------
+    if (dtc_debugfs_enable & DTC_ENABLE_UDP &&
+            dtc_debugfs_time_loc & DTC_TIME_IP_SEND &&
+            dtc_debugfs_target_ip == ((struct iphdr*) skb_network_header(skb))->daddr &&
+            dtc_debugfs_target_port == ((struct udphdr*) skb_transport_header(skb))->dest) {
+        dtc_debugfs_log1((u8*) dtc_debugfs_skb_udp_payload(skb), 4);        
+    }
+
 	err = __ip_local_out(net, sk, skb);
 	if (likely(err == 1))
 		err = dst_output(net, sk, skb);
Index: linux-4.9.82/net/ipv4/udp.c
===================================================================
--- linux-4.9.82.orig/net/ipv4/udp.c
+++ linux-4.9.82/net/ipv4/udp.c
@@ -116,6 +116,9 @@
 #include <net/sock_reuseport.h>
 #include <net/addrconf.h>
 
+// added by dtc ------
+#include "../../../../../../common_folder/dtc_debugfs/dtc_debugfs.h"
+
 struct udp_table udp_table __read_mostly;
 EXPORT_SYMBOL(udp_table);
 
@@ -979,6 +982,14 @@ int udp_sendmsg(struct sock *sk, struct
 	saddr = ipc.addr;
 	ipc.addr = faddr = daddr;
 
+    // added by dtc ------
+    if (dtc_debugfs_enable & DTC_ENABLE_UDP &&
+            dtc_debugfs_time_loc & DTC_TIME_UDP_SEND &&
+            dtc_debugfs_target_ip == daddr &&
+            dtc_debugfs_target_port == dport) {
+        dtc_debugfs_log1(NULL, 0);        
+    }
+
 	sock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);
 
 	if (ipc.opt && ipc.opt->opt.srr) {
@@ -1790,6 +1801,14 @@ int __udp4_lib_rcv(struct sk_buff *skb,
 			skb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
 						 inet_compute_pseudo);
 
+        // added by dtc ------
+        if (dtc_debugfs_enable & DTC_ENABLE_UDP && 
+                dtc_debugfs_time_loc & DTC_TIME_UDP_RECV &&
+                dtc_debugfs_target_ip == saddr &&
+                (dtc_debugfs_target_port == 0 || dtc_debugfs_target_port == uh->source)) {
+            dtc_debugfs_log2((u8*)dtc_debugfs_skb_udp_payload(skb), 4);        
+        }
+
 		ret = udp_queue_rcv_skb(sk, skb);
 
 		/* a return value > 0 means to resubmit the input, but
